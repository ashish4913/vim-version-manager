#!/usr/bin/python

import optparse
import subprocess
import sys




class VimVersionManager:
  # Directory structure:
  #   ~/.vvm                 The root directory for Vim Version Manager.
  #     bin                  For command-line utilities.
  #     src                  Place to store source code of each version.
  #       ...
  #       $fork--$tagname    Naming is the same as ~/.vvm/vims.
  #     vims                 Place to store deployed versions.
  #       vimorg--v7-3-254   Install directory for the original one.
  #       macvim--v7.3-53    Install directory for MacVim.
  #       ...
  #       $fork--$tagname    This is the "version" format.
  #       current            Symbolic link for an install directory.

  # Driver::

  def main(self, args):
    p = optparse.OptionParser(version='%prog 1.2.3')
    p.disable_interspersed_args()
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      p.print_help()
    else:
      subcmd_name = left_args[0]
      try:
        subcmd_func = getattr(self, 'cmd_%s' % subcmd_name)
      except AttributeError:
        die('Subcommand "%s" is not available.' % subcmd_name)
      subcmd_func(left_args)
    return

  # Subcommands::

  def cmd_help(self, args):
    # FIXME: Add more useful description.
    '''Show help message to use Vim Version Manager.'''
    subcmd_names = [n for n in dir(self) if n.startswith('cmd_')]
    subcmd_names.sort()
    longest_subcmd_name = max(len(n) for n in subcmd_names)
    print 'Available commands:'
    for n in subcmd_names:
      print '  %s%s%s' % (
        n[len('cmd_'):],
        ' ' * (longest_subcmd_name - len(n) + 2),
        getattr(self, n).__doc__.split('\n')[0]
      )
    return

  def cmd_install(self, args):
    '''Install a specific version of Vim.'''
    p = optparse.OptionParser()
    p.usage = '%prog install $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to install.')
    version = left_args[0]
    configure_options = left_args[1:]
    self.fetch(version)
    self.checkout(version)
    self.configure(version, configure_options)
    self.make_install(version)
    return

  def cmd_rebuild(self, args):
    '''Rebuild a specific version of Vim.'''
    # FIXME: Implement.
    pass

  def cmd_reinstall(self, args):
    '''Reinstall a specific version of Vim.'''
    # FIXME: Implement.
    pass

  def cmd_uninstall(self, args):
    '''Uninstall a specific version of Vim.'''
    # FIXME: Implement.
    pass

  def cmd_use(self, args):
    '''Use a specific version of Vim as the default one.'''
    # FIXME: Implement.
    pass

  # Utilities::

  def checkout(self, version):
    raise NotImplementedError

  def configure(self, version, configure_options):
    raise NotImplementedError

  def fetch(self, version):
    raise NotImplementedError

  def make_install(self, version):
    raise NotImplementedError




def die(message):
  return exit(message)

def has(progname):
  return invoke('which', progname, exit_on_failure=False) == 0

def invoke(*args, **kw):
  dev_null = open('/dev/null', 'w')
  retcode = subprocess.call(args, stdout=dev_null, stderr=dev_null)
  if retcode != 0 and kw.get('exit_on_failure', True):
    raise RuntimeError('"%s" is failed.' % ' '.join(args))
  else:
    return retcode

def parse_version(version):
  return version.split('--')




if __name__ == '__main__':
  VimVersionManager().main(sys.argv)

# __END__
